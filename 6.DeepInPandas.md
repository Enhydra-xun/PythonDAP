
# 6. Deep In Panndas

# 数据处理的三个阶段

* 数据准备   
* 数据转换   
* 数据聚合   



## 6.1 数据准备
将数据组装成便于用pandas处理的数据结构，包括以下步骤：    
* 加载   
* 组装 
 > 合并 ( merging ) ---- pandas.merge( ) 根据一个/多个键连接多行     
 > 拼接 ( concantenation ) ---- pandas.concat( ) 按照轴把多个对象拼接起来      
 > 组合 ( combine ) ---- pandas.DataFrame.combine_first( ) 从另外一个数据结构获取数据，连接重合的数据，以填充缺失值      
* 变形（轴向旋转）     
* 删除      

### 合并

* 相当于SQL中的JOIN操作   


```python
import numpy as np
import pandas as pd
frame1 = pd.DataFrame({'id':['ball','pencil','pen','mug','ashtray'],
                      'price':[12.33,11.44,33.21,13.23,33.62]})
frame1
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ball</td>
      <td>12.33</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pencil</td>
      <td>11.44</td>
    </tr>
    <tr>
      <th>2</th>
      <td>pen</td>
      <td>33.21</td>
    </tr>
    <tr>
      <th>3</th>
      <td>mug</td>
      <td>13.23</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ashtray</td>
      <td>33.62</td>
    </tr>
  </tbody>
</table>
</div>




```python
frame2 = pd.DataFrame({'id':['pencil','pencil','ball','pen'],
                      'color':['w','r','r','k']})
frame2
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>w</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>1</th>
      <td>r</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>2</th>
      <td>r</td>
      <td>ball</td>
    </tr>
    <tr>
      <th>3</th>
      <td>k</td>
      <td>pen</td>
    </tr>
  </tbody>
</table>
</div>




```python
pd.merge(frame1,frame2)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>id</th>
      <th>price</th>
      <th>color</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ball</td>
      <td>12.33</td>
      <td>r</td>
    </tr>
    <tr>
      <th>1</th>
      <td>pencil</td>
      <td>11.44</td>
      <td>w</td>
    </tr>
    <tr>
      <th>2</th>
      <td>pencil</td>
      <td>11.44</td>
      <td>r</td>
    </tr>
    <tr>
      <th>3</th>
      <td>pen</td>
      <td>33.21</td>
      <td>k</td>
    </tr>
  </tbody>
</table>
</div>




```python
frame1 = pd.DataFrame({'id':['ball','pencil','pen','mug','ashtray'],
                      'color':['w','r','r','k','g'],
                      'brand':['OMG','ABC','ABC','POD','POD']})
frame1
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand</th>
      <th>color</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>OMG</td>
      <td>w</td>
      <td>ball</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ABC</td>
      <td>r</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ABC</td>
      <td>r</td>
      <td>pen</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POD</td>
      <td>k</td>
      <td>mug</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POD</td>
      <td>g</td>
      <td>ashtray</td>
    </tr>
  </tbody>
</table>
</div>




```python
frame2 = pd.DataFrame({'id':['pencil','pencil','ball','pen'],
                      'brand':['OMG','POD','ABC','POD']})
frame2
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>OMG</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POD</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ABC</td>
      <td>ball</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POD</td>
      <td>pen</td>
    </tr>
  </tbody>
</table>
</div>




```python
pd.merge(frame1,frame2)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand</th>
      <th>color</th>
      <th>id</th>
    </tr>
  </thead>
  <tbody>
  </tbody>
</table>
</div>




```python
pd.merge(frame1,frame2,on='id')
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand_x</th>
      <th>color</th>
      <th>id</th>
      <th>brand_y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>OMG</td>
      <td>w</td>
      <td>ball</td>
      <td>ABC</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ABC</td>
      <td>r</td>
      <td>pencil</td>
      <td>OMG</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ABC</td>
      <td>r</td>
      <td>pencil</td>
      <td>POD</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ABC</td>
      <td>r</td>
      <td>pen</td>
      <td>POD</td>
    </tr>
  </tbody>
</table>
</div>




```python
pd.merge(frame1,frame2,on='brand')
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand</th>
      <th>color</th>
      <th>id_x</th>
      <th>id_y</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>OMG</td>
      <td>w</td>
      <td>ball</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ABC</td>
      <td>r</td>
      <td>pencil</td>
      <td>ball</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ABC</td>
      <td>r</td>
      <td>pen</td>
      <td>ball</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POD</td>
      <td>k</td>
      <td>mug</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>4</th>
      <td>POD</td>
      <td>k</td>
      <td>mug</td>
      <td>pen</td>
    </tr>
    <tr>
      <th>5</th>
      <td>POD</td>
      <td>g</td>
      <td>ashtray</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>6</th>
      <td>POD</td>
      <td>g</td>
      <td>ashtray</td>
      <td>pen</td>
    </tr>
  </tbody>
</table>
</div>



* 合并标准不同，结果差异很大   
* 如果DataFrame 基准列名称不一致，    
 用left-on 和 right_on指定第一/二个DataFrame的基准列


```python
frame2.columns = ['brand','sid']
frame2
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand</th>
      <th>sid</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>OMG</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>1</th>
      <td>POD</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ABC</td>
      <td>ball</td>
    </tr>
    <tr>
      <th>3</th>
      <td>POD</td>
      <td>pen</td>
    </tr>
  </tbody>
</table>
</div>




```python
pd.merge(frame1,frame2,left_on='id',right_on='sid')
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>brand_x</th>
      <th>color</th>
      <th>id</th>
      <th>brand_y</th>
      <th>sid</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>OMG</td>
      <td>w</td>
      <td>ball</td>
      <td>ABC</td>
      <td>ball</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ABC</td>
      <td>r</td>
      <td>pencil</td>
      <td>OMG</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>2</th>
      <td>ABC</td>
      <td>r</td>
      <td>pencil</td>
      <td>POD</td>
      <td>pencil</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ABC</td>
      <td>r</td>
      <td>pen</td>
      <td>POD</td>
      <td>pen</td>
    </tr>
  </tbody>
</table>
</div>



* merge( )默认执行的是**内连接操作**    
* 上述结果中的键是**由交叉操作( intersection )**得到的    
 其他选项有**左连接、右连接、外连接**；连接类型用 how 指定

> frame2.colmns = ['brand','id']     
> pd.merge(frame1,frame2,on='id')    
> * 辣鸡！都是bug    // **key error 'id'** //      

* 要合并多个键，把多个键赋给 on 选项   

> pd.merge(frame1,frame2,on=['id','brand'],how='outer')
> * 辣鸡！还是bug // **key error 'id'** //

* 根据索引合并   
 有时合并操作不是用DataFrame的列，而是用索引作为键。把left_index和right_index的值设为True，即可。
> pd.merge(frame1,frame2,right_index=True,left_index=True)

* 但是DataFrame对象的join()更适合根据索引合并，可以用来合并多个索引相同/索引相同但列不同的DF对象。    
> frame2.columns = ['brand2','id2']      
> frame1.join(frame2)

## 6.2 拼接

拼接（concatenation）


```python
array1 = np.array([[0,1,2],
                   [3,4,5],
                   [6,7,8]])
array2 = np.array([[6,7,8], 
                   [9,10,11],
                   [12,13,14]])
np.concatenate([array1,array2],axis=1)
```




    array([[ 0,  1,  2,  6,  7,  8],
           [ 3,  4,  5,  9, 10, 11],
           [ 6,  7,  8, 12, 13, 14]])




```python
np.concatenate([array1,array2],axis=0)
```




    array([[ 0,  1,  2],
           [ 3,  4,  5],
           [ 6,  7,  8],
           [ 6,  7,  8],
           [ 9, 10, 11],
           [12, 13, 14]])



* 带编号的轴，可进一步拓展数组拼接功能。pandas的concat( )实现了按轴拼接的功能。


```python
ser1 = pd.Series(np.random.rand(4),index=[1,2,3,4])
ser1
```




    1    0.399921
    2    0.076116
    3    0.642045
    4    0.419668
    dtype: float64




```python
ser2 = pd.Series(np.random.rand(4),index=[5,6,7,8])
ser2
```




    5    0.552892
    6    0.161829
    7    0.799039
    8    0.590747
    dtype: float64




```python
pd.concat([ser1,ser2])
```




    1    0.399921
    2    0.076116
    3    0.642045
    4    0.419668
    5    0.552892
    6    0.161829
    7    0.799039
    8    0.590747
    dtype: float64



concat( )默认按照axis=0这条轴拼接数据，返回Series对象。如果指定axis=1，返回结果将是DataFrame对象。


```python
ser3=pd.concat([ser1,ser2],axis=1)
ser3
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.399921</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.076116</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.642045</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.419668</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>0.552892</td>
    </tr>
    <tr>
      <th>6</th>
      <td>NaN</td>
      <td>0.161829</td>
    </tr>
    <tr>
      <th>7</th>
      <td>NaN</td>
      <td>0.799039</td>
    </tr>
    <tr>
      <th>8</th>
      <td>NaN</td>
      <td>0.590747</td>
    </tr>
  </tbody>
</table>
</div>



* 结果中无重回数据，因而刚执行的是**外连接操作**。把join 设置为'inner'，可执行**内连接操作**。


```python
pd.concat([ser1,ser3],axis=1,join='inner')
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>0</th>
      <th>1</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.399921</td>
      <td>0.399921</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.076116</td>
      <td>0.076116</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.642045</td>
      <td>0.642045</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.419668</td>
      <td>0.419668</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>



此操作的问题是，从结果中无法识被拼接的部分。如果在用于拼接的轴上创建等级索引，需要借助keys来完成。


```python
pd.concat([ser1,ser2],keys=[1,2])
```




    1  1    0.399921
       2    0.076116
       3    0.642045
       4    0.419668
    2  5    0.552892
       6    0.161829
       7    0.799039
       8    0.590747
    dtype: float64



按照axis=1拼接Series对象，所指定的键变为拼接后得到的DataFrame对象各列的名称。


```python
pd.concat([ser1,ser2],axis=1,keys=[1,2])
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.399921</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.076116</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.642045</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.419668</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>5</th>
      <td>NaN</td>
      <td>0.552892</td>
    </tr>
    <tr>
      <th>6</th>
      <td>NaN</td>
      <td>0.161829</td>
    </tr>
    <tr>
      <th>7</th>
      <td>NaN</td>
      <td>0.799039</td>
    </tr>
    <tr>
      <th>8</th>
      <td>NaN</td>
      <td>0.590747</td>
    </tr>
  </tbody>
</table>
</div>



* DataFrame对象拼接方法与之相同

### 6.2.1 组合

* 当无法通过合并或者拼接方法组合数据，比如两个数据集的索引完全/部分重合。    
 combine_first( ) 可以用来组合Series对象，同时对其数据。    


```python
ser1 = pd.Series(np.random.rand(5),index=[1,2,3,4,5])
ser1
```




    1    0.865614
    2    0.372295
    3    0.925969
    4    0.130369
    5    0.847461
    dtype: float64




```python
ser2 = pd.Series(np.random.rand(4),index=[2,4,5,6])
ser2
```




    2    0.502107
    4    0.517182
    5    0.579815
    6    0.386595
    dtype: float64




```python
ser1.combine_first(ser2)
```




    1    0.865614
    2    0.372295
    3    0.925969
    4    0.130369
    5    0.847461
    6    0.386595
    dtype: float64




```python
ser2.combine_first(ser1)
```




    1    0.865614
    2    0.502107
    3    0.925969
    4    0.517182
    5    0.579815
    6    0.386595
    dtype: float64



如果要部分合并，只要指定合并中的部分即可


```python
ser1[:3].combine_first(ser2[:3])
```




    1    0.865614
    2    0.372295
    3    0.925969
    4    0.517182
    5    0.579815
    dtype: float64



### 6.2.2 轴向旋转

轴向旋转（pivoting）

* 按等级索引旋转   
 包含两个基础操作：   
 > 入栈（stacking）：转换数据结构，列变为行。   
 > 出栈（unstacking）：把行转为列。


```python
frame1 = pd.DataFrame(np.arange(9).reshape(3,3),
                      index=['w','k','r'],
                      columns=['ball','pen','pencil'])
frame1
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ball</th>
      <th>pen</th>
      <th>pencil</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>w</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>k</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>r</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>



对DataFrame使用stack( )，会把列转变成行，得到Series对象。


```python
ser5 = frame1.stack()
ser5
```




    w  ball      0
       pen       1
       pencil    2
    k  ball      3
       pen       4
       pencil    5
    r  ball      6
       pen       7
       pencil    8
    dtype: int64




```python
ser5.unstack()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ball</th>
      <th>pen</th>
      <th>pencil</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>w</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <th>k</th>
      <td>3</td>
      <td>4</td>
      <td>5</td>
    </tr>
    <tr>
      <th>r</th>
      <td>6</td>
      <td>7</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>



出栈操作可以应用于不同层级，为unstack( )传入层级的编号或名称，即可对相应层级进行操作。


```python
ser5.unstack(0)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>w</th>
      <th>k</th>
      <th>r</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>ball</th>
      <td>0</td>
      <td>3</td>
      <td>6</td>
    </tr>
    <tr>
      <th>pen</th>
      <td>1</td>
      <td>4</td>
      <td>7</td>
    </tr>
    <tr>
      <th>pencil</th>
      <td>2</td>
      <td>5</td>
      <td>8</td>
    </tr>
  </tbody>
</table>
</div>



## 6.3 数据转换

### 6.3.1 删除重复元素



```python
dframe = pd.DataFrame({'color':['w','w','r','r','w'],
                        'value':[2,1,3,3,2]})
dframe
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>w</td>
      <td>2</td>
    </tr>
    <tr>
      <th>1</th>
      <td>w</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>r</td>
      <td>3</td>
    </tr>
    <tr>
      <th>3</th>
      <td>r</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>w</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



* duplicated( )用来检测重复的行，返回元素为bool的Series对象。   
 每个元素对应一行，如果和其他行重复，为True；如果不重复，为False。   


```python
dframe.duplicated()
```




    0    False
    1    False
    2    False
    3     True
    4     True
    dtype: bool



过滤操作：


```python
dframe[dframe.duplicated()]
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3</th>
      <td>r</td>
      <td>3</td>
    </tr>
    <tr>
      <th>4</th>
      <td>w</td>
      <td>2</td>
    </tr>
  </tbody>
</table>
</div>



通常，重复的行都需要从DataFrame删除，drop_duplicates( )实现了删除功能，返回的都是删除重复行后的DataFrane对象。

> tokens = [s.strip( ) for s in text.split(',')]

### 6.3.2 映射

定义映射关系，最好用dict。    
* 都以dict对象为参数    
 > replace( ): 替换元素    
 > map( ): 新建一列     
 > rename( ): 替换索引    
 
> frame.replace(newcolors)      
> ser = pd.replace(np.nan,0)      
> frame['price'] = frame['item'].map(price)     
> frame.rename(reindex)     
> frame.rename(index={1;'first},columns={'item':'object'})    

## 6.4 离散化和面元划分

在处理大量连续型数据时，为便于区分，需要把数据打散成几个类别，比如把读书的取值范围划分为一个个小区间，统计每个区间的元素数量或其他统计量；另一种情况是，对总体作出精确的测量，得到了大量个体这种情况下需要把元素分成几个类别，然后分析每个类别的个体数量及其他统计量。

* 已知实验数据范围0～100，所以可以把数据均分；例如分成四部分，即四个**面元（bin）**。     
 第一个面元包含0～25的值，第二个为26～50，第三个为51～75，最后一个为76～100.   
 用pandas划分面元之前首先要定义一个数组result，储存用于面元划分的各数值。   
 然后，对result数组用cut( )函数，同时传入bins变量作为参数。    



```python
result = range(0,101)
bins=[0,25,50,75,100]
cat = pd.cut(result,bins)
cat
```




    [NaN, (0, 25], (0, 25], (0, 25], (0, 25], ..., (75, 100], (75, 100], (75, 100], (75, 100], (75, 100]]
    Length: 101
    Categories (4, interval[int64]): [(0, 25] < (25, 50] < (50, 75] < (75, 100]]




```python
pd.value_counts(cat)
```




    (75, 100]    25
    (50, 75]     25
    (25, 50]     25
    (0, 25]      25
    dtype: int64



cut( )函数返回的对象为Categorical（类别型）类型，可以看作一个字符串数组，元素为面元名称。   
该对象内部levels数组为不同内部类别的名称，labels数组的元素数量和results数组相同，labels数组各数字表示results元素所属面元。

除了cut( )函数，还有另一个划分面元的函数qcut( )，用此函数划分的函数能保证每个面元个体数相同，但每个面元的区间大小不等。


```python
quintiles = pd.qcut(result,5)
quintiles
```




    [(-0.001, 20.0], (-0.001, 20.0], (-0.001, 20.0], (-0.001, 20.0], (-0.001, 20.0], ..., (80.0, 100.0], (80.0, 100.0], (80.0, 100.0], (80.0, 100.0], (80.0, 100.0]]
    Length: 101
    Categories (5, interval[float64]): [(-0.001, 20.0] < (20.0, 40.0] < (40.0, 60.0] < (60.0, 80.0] < (80.0, 100.0]]




```python
pd.value_counts(quintiles)
```




    (-0.001, 20.0]    21
    (80.0, 100.0]     20
    (60.0, 80.0]      20
    (40.0, 60.0]      20
    (20.0, 40.0]      20
    dtype: int64



* **异常值检测和过滤**

* **etc**    
 先创建一个包含三列的DataFrame对象，每列都包含1000个随机数。   
 用describe( )查看统计量：


```python
randframe = pd.DataFrame(np.random.randn(1000,3))
randframe.describe()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>1000.000000</td>
      <td>1000.000000</td>
      <td>1000.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.056358</td>
      <td>0.025794</td>
      <td>-0.015575</td>
    </tr>
    <tr>
      <th>std</th>
      <td>1.002482</td>
      <td>1.003585</td>
      <td>0.960349</td>
    </tr>
    <tr>
      <th>min</th>
      <td>-3.112580</td>
      <td>-3.223901</td>
      <td>-3.234115</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>-0.620683</td>
      <td>-0.637269</td>
      <td>-0.664252</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.035661</td>
      <td>0.033352</td>
      <td>-0.021866</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>0.692124</td>
      <td>0.694613</td>
      <td>0.656074</td>
    </tr>
    <tr>
      <th>max</th>
      <td>3.523428</td>
      <td>2.710260</td>
      <td>2.869098</td>
    </tr>
  </tbody>
</table>
</div>



假设将比std大3倍大元素视为异常值，用std( )可以求的DataFrame对象每一列的标准差。


```python
randframe.std()
```




    0    1.002482
    1    1.003585
    2    0.960349
    dtype: float64



根据每一列的标准差，对DF对象所有元素进行过滤，借助any( )，就可以对每列应用筛选条件。


```python
randframe[(np.abs(randframe)>(3*randframe.std())).any(1)]
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>107</th>
      <td>3.133253</td>
      <td>-0.654378</td>
      <td>1.455495</td>
    </tr>
    <tr>
      <th>189</th>
      <td>0.934462</td>
      <td>0.000348</td>
      <td>-3.040142</td>
    </tr>
    <tr>
      <th>242</th>
      <td>-0.291509</td>
      <td>-3.075147</td>
      <td>0.110602</td>
    </tr>
    <tr>
      <th>421</th>
      <td>-3.062809</td>
      <td>-1.999317</td>
      <td>-0.683621</td>
    </tr>
    <tr>
      <th>426</th>
      <td>3.523428</td>
      <td>-0.468318</td>
      <td>-0.794309</td>
    </tr>
    <tr>
      <th>607</th>
      <td>-2.093827</td>
      <td>-3.223901</td>
      <td>-0.484205</td>
    </tr>
    <tr>
      <th>674</th>
      <td>3.195850</td>
      <td>1.379003</td>
      <td>-0.114405</td>
    </tr>
    <tr>
      <th>759</th>
      <td>3.341688</td>
      <td>-0.443194</td>
      <td>1.500264</td>
    </tr>
    <tr>
      <th>855</th>
      <td>-0.237716</td>
      <td>1.188255</td>
      <td>-3.234115</td>
    </tr>
    <tr>
      <th>894</th>
      <td>-3.112580</td>
      <td>0.251672</td>
      <td>0.862399</td>
    </tr>
  </tbody>
</table>
</div>



## 排序

* 用numpy.random.permutation( )，调整Series对象或者DataFrame对象各行的顺序（随机排序）。     
* 创建一个元素为整数且按照升序排列的DF对象。


```python
nframe = pd.DataFrame(np.arange(25).reshape(5,5))
nframe
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
    <tr>
      <th>3</th>
      <td>15</td>
      <td>16</td>
      <td>17</td>
      <td>18</td>
      <td>19</td>
    </tr>
    <tr>
      <th>4</th>
      <td>20</td>
      <td>21</td>
      <td>22</td>
      <td>23</td>
      <td>24</td>
    </tr>
  </tbody>
</table>
</div>



* 用permutation( )创建一个包含0～4（顺序随机）这五个整数的数组。     
 按此数组元素的顺序为DF对象的行排序。   


```python
new_order = np.random.permutation(5)
new_order
```




    array([4, 1, 3, 2, 0])



* 对DF对象的所有行应用take( )函数，把新的次序传给它。


```python
nframe.take(new_order)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>4</th>
      <td>20</td>
      <td>21</td>
      <td>22</td>
      <td>23</td>
      <td>24</td>
    </tr>
    <tr>
      <th>1</th>
      <td>5</td>
      <td>6</td>
      <td>7</td>
      <td>8</td>
      <td>9</td>
    </tr>
    <tr>
      <th>3</th>
      <td>15</td>
      <td>16</td>
      <td>17</td>
      <td>18</td>
      <td>19</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
  </tbody>
</table>
</div>



DF对象各行位置已经改变，新索引的顺序和new_orde数组元素顺序一致。   
* 还可以只对DF对象的一部分进行排序操作，将生成一个数组，只包含特定索引范围的数据。


```python
new_order = [3,4,2]
nframe.take(new_order)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>3</th>
      <td>15</td>
      <td>16</td>
      <td>17</td>
      <td>18</td>
      <td>19</td>
    </tr>
    <tr>
      <th>4</th>
      <td>20</td>
      <td>21</td>
      <td>22</td>
      <td>23</td>
      <td>24</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
  </tbody>
</table>
</div>



### 随机取样

* 从大规模DF中**随机取样**，最快的方法：np.random.randint( )


```python
sample = np.random.randint(0,len(nframe),size=3)
sample
```




    array([2, 0, 2])




```python
nframe.take(sample)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
    <tr>
      <th>0</th>
      <td>0</td>
      <td>1</td>
      <td>2</td>
      <td>3</td>
      <td>4</td>
    </tr>
    <tr>
      <th>2</th>
      <td>10</td>
      <td>11</td>
      <td>12</td>
      <td>13</td>
      <td>14</td>
    </tr>
  </tbody>
</table>
</div>



## 6.6 字符串处理

### 6.6.1 内置的字符串处理方法



```python
text = '16 Bolton Avenue , Boston '
text.split(',')
```




    ['16 Bolton Avenue ', ' Boston ']



切分后的第一个元素常以空白字符结尾，因此为解决这个问题：
* 用**split( )**切分后，再用**strip( )**删除多余**空白字符，换行符**


```python
token = [s.strip() for s in text.split(',')]
token
```




    ['16 Bolton Avenue', 'Boston']



如果元素较少且固定不变，可使用以下赋值方法


```python
address, city = [s.strip() for s in text.split(',')]
address
```




    '16 Bolton Avenue'




```python
city
```




    'Boston'



* 通常还需要其逆操作，把多个字符串拼接在一起练成长文本。
* 最简单的方法是用‘+’运算符把几个文本片段拼接在一起，适用于只有两三个字符串。


```python
address+','+city
```




    '16 Bolton Avenue,Boston'



* 如要拼接很多字符串，更实用的方法是用join( )函数 


```python
strings = ['A+','A','A-','B','BB','BBB','C+']
';'.join(strings)
```




    'A+;A;A-;B;BB;BBB;C+'



另一类是查找子串，in 关键字是检测子串最好方法。    
index( ) 和find( )能实现字符串查找。


```python
'Boston' in text
```




    True




```python
text.index('Boston')
```




    19




```python
text.find('Boston')
```




    19



这两个函数均返回子串在字符串中的索引，但是在没有找到子串时表现不同。   
* index( )会报错，find( )返回-1.
* 用count( )函数获知字符或者字符串组合在文本中出现次数。


```python
text.count('e')
```




    2




```python
text.count('Avenue')
```




    1



针对字符串的另一个操作是替换或删除字符串中的子串/单个字符。   
都可以用replace( )函数实现，如用空字符替代子串等同于删除子串。


```python
text.replace('Avenue','Street')
```




    '16 Bolton Street , Boston '




```python
text.replace('1','')
```




    '6 Bolton Avenue , Boston '



### 6.6.2 正则表达式

单条正则表达式即regex。   
Py内置的 **re 模块** 用于操作 **regex对象** 。


re模块提供的函数分为：     
 > 模式匹配     
 > 替换     
 > 切分     

例如，表示一个/多个空白字符的正则表达式为\s+ 。    
re模块中也有split函数，能够以正则表达式作为分隔符。


```python
import re
text = 'This is     an\t odd \n text!'
re.split('\s+',text)
```




    ['This', 'is', 'an', 'odd', 'text!']



* **调用re.split( )时，首先编译正则表达式，然后再作为参数传入的文本上调用split( )。   
  可以用re.complie( )函数编译正则表达式，得到一个可以重用的regex对象，节省CPU周期。**


```python
regex = re.compile('\s+')
regex.split(text)
```




    ['This', 'is', 'an', 'odd', 'text!']



* findall( ) 可以匹配文本中所有符合正则表达式的子串。   
 返回一个列表，元素为文本中所有符合正则表达式的子串。


```python
text = 'This is my address: 16 Bolton Avenue, Boston'
re.findall('A\w+',text)
```




    ['Avenue']




```python
re.findall('[A,a]\w+',text)
```




    ['address', 'Avenue']



和findall( ) 函数相关的两个函数为**match( ), search( )** .    
findall( )返回一列所有符合模式的子串，    
search( )仅返回第一处符合模式的子串，且返回结果为一个特殊类型的对象。


```python
re.search('[A,a]\w+',text)
```




    <_sre.SRE_Match object; span=(11, 18), match='address'>



该对象不包含任何模式的子串，而是子串在字符串中的开始和结束位置。


```python
search = re.search('[A,a]\w+',text)
search.start()
```




    11




```python
search.end()
```




    18




```python
text[search.start():search.end()]
```




    'address'



match( )从字符串开头开始匹配；如果第一个字符就不匹配，就不会再搜索字符串内部，   
**如果没有找到任何匹配的子串，不会返回任何对象。**   
如果有返回内容，则返回对象与search( )相同。


```python
re.match('[A,a]\w+',text)
```

## 6.7 数据聚合

### 6.7.1 GroupBy

* GroupBy通常指其内部机制——SPLIT-APPLY-COMBINE（分组-用函数处理-合并结果）过程。   
* 由三个阶段组成：     
 > 分组：将数据集分成多组     
 > 用函数处理：用函数处理每一组     
 > 合并：把不同组得到的结果合并起来      
 
### 6.7.2 示例


```python
frame = pd.DataFrame({'color':['w','r','g','r','g'],
                     'object':['pen','pencil','pencil','ashtray','pen'],
                     'price1':[5.56,4.20,1.30,0.56,2.75],
                     'price2':[4.75,4.12,1.60,0.75,3.15]})
frame
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>object</th>
      <th>price1</th>
      <th>price2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>w</td>
      <td>pen</td>
      <td>5.56</td>
      <td>4.75</td>
    </tr>
    <tr>
      <th>1</th>
      <td>r</td>
      <td>pencil</td>
      <td>4.20</td>
      <td>4.12</td>
    </tr>
    <tr>
      <th>2</th>
      <td>g</td>
      <td>pencil</td>
      <td>1.30</td>
      <td>1.60</td>
    </tr>
    <tr>
      <th>3</th>
      <td>r</td>
      <td>ashtray</td>
      <td>0.56</td>
      <td>0.75</td>
    </tr>
    <tr>
      <th>4</th>
      <td>g</td>
      <td>pen</td>
      <td>2.75</td>
      <td>3.15</td>
    </tr>
  </tbody>
</table>
</div>



要使用color列的组标签，计算price1列的均值，     
可以先获取到price1列，再调用groupby( )，用参数指定color列。


```python
group = frame['price1'].groupby(frame['color'])
group
```




    <pandas.core.groupby.SeriesGroupBy object at 0x108d18ef0>



刚才得到的对象为GroupBy对象。刚才只是把计算需要的所有信息放在一起，即分组操作，把含有相同颜色的行分到同一个组里。   
** *调用GroupBy对象的groups属性，查看DF各行分组情况* **


```python
group.groups
```




    {'g': Int64Index([2, 4], dtype='int64'),
     'r': Int64Index([1, 3], dtype='int64'),
     'w': Int64Index([0], dtype='int64')}




```python
group.mean()
```




    color
    g    2.025
    r    2.380
    w    5.560
    Name: price1, dtype: float64




```python
group.sum()
```




    color
    g    4.05
    r    4.76
    w    5.56
    Name: price1, dtype: float64



### 6.7.3 等级分组

可以用多列，即用多个键，按照等级关系分组。


```python
ggroup = frame['price1'].groupby([frame['color'],frame['object']])
ggroup.groups
```




    {('g', 'pen'): Int64Index([4], dtype='int64'),
     ('g', 'pencil'): Int64Index([2], dtype='int64'),
     ('r', 'ashtray'): Int64Index([3], dtype='int64'),
     ('r', 'pencil'): Int64Index([1], dtype='int64'),
     ('w', 'pen'): Int64Index([0], dtype='int64')}




```python
ggroup.sum()
```




    color  object 
    g      pen        2.75
           pencil     1.30
    r      ashtray    0.56
           pencil     4.20
    w      pen        5.56
    Name: price1, dtype: float64



可以按照多列数据或整个DF把数据分为几组。    
如果不想重复多次使用GroupBy对象，最方便的方法是一次把所有的分组依据和计算方法都指定好，无需定义任何中间变量。


```python
frame[['price1','price2']].groupby(frame['color']).mean()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price1</th>
      <th>price2</th>
    </tr>
    <tr>
      <th>color</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>g</th>
      <td>2.025</td>
      <td>2.375</td>
    </tr>
    <tr>
      <th>r</th>
      <td>2.380</td>
      <td>2.435</td>
    </tr>
    <tr>
      <th>w</th>
      <td>5.560</td>
      <td>4.750</td>
    </tr>
  </tbody>
</table>
</div>




```python
frame.groupby(frame['color']).mean()
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price1</th>
      <th>price2</th>
    </tr>
    <tr>
      <th>color</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>g</th>
      <td>2.025</td>
      <td>2.375</td>
    </tr>
    <tr>
      <th>r</th>
      <td>2.380</td>
      <td>2.435</td>
    </tr>
    <tr>
      <th>w</th>
      <td>5.560</td>
      <td>4.750</td>
    </tr>
  </tbody>
</table>
</div>



## 6.8 组迭代

* GroupBy对象还支持迭代操作，可生成一系列由各组名称及其数据部分组成的元组。


```python
for name,group in frame.groupby('color'):
    print(name)
    print(group)
```

    g
      color  object  price1  price2
    2     g  pencil    1.30    1.60
    4     g     pen    2.75    3.15
    r
      color   object  price1  price2
    1     r   pencil    4.20    4.12
    3     r  ashtray    0.56    0.75
    w
      color object  price1  price2
    0     w    pen    5.56    4.75


### 6.8.1 链式转换

用函数进行计算/操作时，不管各组如何得到及选取标准，最终结果不是Series就是DF，保留了索引系统和列名称。   
因此，在GroupBy过程中任何一个阶段都可以任意选择一列数据。

### 6.8.2 分组函数

有很多函数不是专门为GroupBy对象实现的，却适用于Series结构。
例如：用quantile计算分位数


```python
group = frame.groupby('color')
group['price1'].quantile(0.6)
```




    color
    g    2.170
    r    2.744
    w    5.560
    Name: price1, dtype: float64



**也可以自定义聚合函数，将其作为参数传给agg( )**


```python
def ranging(series):
    return series.max()-series.min()
group['price1'].agg(ranging)
```




    color
    g    1.45
    r    3.64
    w    0.00
    Name: price1, dtype: float64




```python
group.agg(ranging)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price1</th>
      <th>price2</th>
    </tr>
    <tr>
      <th>color</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>g</th>
      <td>1.45</td>
      <td>1.55</td>
    </tr>
    <tr>
      <th>r</th>
      <td>3.64</td>
      <td>3.37</td>
    </tr>
    <tr>
      <th>w</th>
      <td>0.00</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>
</div>



还可以同时使用多个聚合函数，把存放有表示聚合操作类型的数组传给agg。   
DF为其添加新列


```python
group['price1'].agg(['mean','std',ranging])
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>mean</th>
      <th>std</th>
      <th>ranging</th>
    </tr>
    <tr>
      <th>color</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>g</th>
      <td>2.025</td>
      <td>1.025305</td>
      <td>1.45</td>
    </tr>
    <tr>
      <th>r</th>
      <td>2.380</td>
      <td>2.573869</td>
      <td>3.64</td>
    </tr>
    <tr>
      <th>w</th>
      <td>5.560</td>
      <td>NaN</td>
      <td>0.00</td>
    </tr>
  </tbody>
</table>
</div>



## 6.9 高级数据聚合

transform( ) 和 apply( )函数，可以用来执行多种及很复杂的组操作。
假设想把下面的内容放在同一个DF中：


```python
frame = pd.DataFrame({'color':['w','r','g','r','g'],
                     'price1':[5.56,4.20,1.30,0.56,2.75],
                     'price2':[4.75,4.12,1.60,0.75,3.15]})
frame
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>price1</th>
      <th>price2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>w</td>
      <td>5.56</td>
      <td>4.75</td>
    </tr>
    <tr>
      <th>1</th>
      <td>r</td>
      <td>4.20</td>
      <td>4.12</td>
    </tr>
    <tr>
      <th>2</th>
      <td>g</td>
      <td>1.30</td>
      <td>1.60</td>
    </tr>
    <tr>
      <th>3</th>
      <td>r</td>
      <td>0.56</td>
      <td>0.75</td>
    </tr>
    <tr>
      <th>4</th>
      <td>g</td>
      <td>2.75</td>
      <td>3.15</td>
    </tr>
  </tbody>
</table>
</div>




```python
sums = frame.groupby('color').sum().add_prefix('tot_')
sums
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>tot_price1</th>
      <th>tot_price2</th>
    </tr>
    <tr>
      <th>color</th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>g</th>
      <td>4.05</td>
      <td>4.75</td>
    </tr>
    <tr>
      <th>r</th>
      <td>4.76</td>
      <td>4.87</td>
    </tr>
    <tr>
      <th>w</th>
      <td>5.56</td>
      <td>4.75</td>
    </tr>
  </tbody>
</table>
</div>




```python
pd.merge(frame,sums,left_on='color',right_index=True)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>price1</th>
      <th>price2</th>
      <th>tot_price1</th>
      <th>tot_price2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>w</td>
      <td>5.56</td>
      <td>4.75</td>
      <td>5.56</td>
      <td>4.75</td>
    </tr>
    <tr>
      <th>1</th>
      <td>r</td>
      <td>4.20</td>
      <td>4.12</td>
      <td>4.76</td>
      <td>4.87</td>
    </tr>
    <tr>
      <th>3</th>
      <td>r</td>
      <td>0.56</td>
      <td>0.75</td>
      <td>4.76</td>
      <td>4.87</td>
    </tr>
    <tr>
      <th>2</th>
      <td>g</td>
      <td>1.30</td>
      <td>1.60</td>
      <td>4.05</td>
      <td>4.75</td>
    </tr>
    <tr>
      <th>4</th>
      <td>g</td>
      <td>2.75</td>
      <td>3.15</td>
      <td>4.05</td>
      <td>4.75</td>
    </tr>
  </tbody>
</table>
</div>



可以用merge把聚合操作的计算结果添加到DF对象每一行。     
也可以用transform实现操作，它还可以根据DF对象每一行的关键字显示聚合结果。


```python
frame.groupby('color').transform(np.sum).add_prefix('tot_')
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>tot_price1</th>
      <th>tot_price2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>5.56</td>
      <td>4.75</td>
    </tr>
    <tr>
      <th>1</th>
      <td>4.76</td>
      <td>4.87</td>
    </tr>
    <tr>
      <th>2</th>
      <td>4.05</td>
      <td>4.75</td>
    </tr>
    <tr>
      <th>3</th>
      <td>4.76</td>
      <td>4.87</td>
    </tr>
    <tr>
      <th>4</th>
      <td>4.05</td>
      <td>4.75</td>
    </tr>
  </tbody>
</table>
</div>



* 由此可见，transform更适合用作聚合操作，但是它对参数有特定要求：   
 作为参数的函数必须生成一个标量（聚合），因为只有这样才能进行广播。    
 
* apply适用于执行更一般的GroupBy操作，此操作完全实现了SPLIT-APPLY-COMBINE机制。   
 它把对象分为几部分之后，再用函数处理每一部分，各步骤之间用链式方法连接在一起。


```python
frame = pd.DataFrame({'color':['w','k','w','w','k','k'],
                      'status':['up','up','down','down','down','up'],
                      'value1':[12.33,14.55,22.34,27.84,23.40,18.33],
                      'value2':[11.23,31.80,29.99,31.18,18.25,22.44]})
frame
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>status</th>
      <th>value1</th>
      <th>value2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>w</td>
      <td>up</td>
      <td>12.33</td>
      <td>11.23</td>
    </tr>
    <tr>
      <th>1</th>
      <td>k</td>
      <td>up</td>
      <td>14.55</td>
      <td>31.80</td>
    </tr>
    <tr>
      <th>2</th>
      <td>w</td>
      <td>down</td>
      <td>22.34</td>
      <td>29.99</td>
    </tr>
    <tr>
      <th>3</th>
      <td>w</td>
      <td>down</td>
      <td>27.84</td>
      <td>31.18</td>
    </tr>
    <tr>
      <th>4</th>
      <td>k</td>
      <td>down</td>
      <td>23.40</td>
      <td>18.25</td>
    </tr>
    <tr>
      <th>5</th>
      <td>k</td>
      <td>up</td>
      <td>18.33</td>
      <td>22.44</td>
    </tr>
  </tbody>
</table>
</div>




```python
frame.groupby(['color','status']).apply(lambda x: x.max())
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th></th>
      <th>color</th>
      <th>status</th>
      <th>value1</th>
      <th>value2</th>
    </tr>
    <tr>
      <th>color</th>
      <th>status</th>
      <th></th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th rowspan="2" valign="top">k</th>
      <th>down</th>
      <td>k</td>
      <td>down</td>
      <td>23.40</td>
      <td>18.25</td>
    </tr>
    <tr>
      <th>up</th>
      <td>k</td>
      <td>up</td>
      <td>18.33</td>
      <td>31.80</td>
    </tr>
    <tr>
      <th rowspan="2" valign="top">w</th>
      <th>down</th>
      <td>w</td>
      <td>down</td>
      <td>27.84</td>
      <td>31.18</td>
    </tr>
    <tr>
      <th>up</th>
      <td>w</td>
      <td>up</td>
      <td>12.33</td>
      <td>11.23</td>
    </tr>
  </tbody>
</table>
</div>




```python
frame.rename(index=str)
```




<div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>color</th>
      <th>status</th>
      <th>value1</th>
      <th>value2</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>w</td>
      <td>up</td>
      <td>12.33</td>
      <td>11.23</td>
    </tr>
    <tr>
      <th>1</th>
      <td>k</td>
      <td>up</td>
      <td>14.55</td>
      <td>31.80</td>
    </tr>
    <tr>
      <th>2</th>
      <td>w</td>
      <td>down</td>
      <td>22.34</td>
      <td>29.99</td>
    </tr>
    <tr>
      <th>3</th>
      <td>w</td>
      <td>down</td>
      <td>27.84</td>
      <td>31.18</td>
    </tr>
    <tr>
      <th>4</th>
      <td>k</td>
      <td>down</td>
      <td>23.40</td>
      <td>18.25</td>
    </tr>
    <tr>
      <th>5</th>
      <td>k</td>
      <td>up</td>
      <td>18.33</td>
      <td>22.44</td>
    </tr>
  </tbody>
</table>
</div>


