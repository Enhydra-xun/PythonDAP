
## 3.4 矩阵运算

### 3.4.2 矩阵积（mastrix produet）



```python
import numpy as np
A= np.arange(0,9).reshape(3,3)
A
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])




```python
B=np.ones((3,3))
B
```




    array([[ 1.,  1.,  1.],
           [ 1.,  1.,  1.],
           [ 1.,  1.,  1.]])




```python
A*B
```




    array([[ 0.,  1.,  2.],
           [ 3.,  4.,  5.],
           [ 6.,  7.,  8.]])




```python
np.dot(A,B)
```




    array([[  3.,   3.,   3.],
           [ 12.,  12.,  12.],
           [ 21.,  21.,  21.]])




```python
A.dot(B)
```




    array([[  3.,   3.,   3.],
           [ 12.,  12.,  12.],
           [ 21.,  21.,  21.]])




```python
B.dot(A)
```




    array([[  9.,  12.,  15.],
           [  9.,  12.,  15.],
           [  9.,  12.,  15.]])



### 3.4.5 通用函数（universal function）

* as short as 'unfunc'
* 对array中各个元素逐一计算


```python
a = np.arange(1,5)
print(np.sqrt(a))
print(np.log(a))
print(np.sin(a))
```

    [ 1.          1.41421356  1.73205081  2.        ]
    [ 0.          0.69314718  1.09861229  1.38629436]
    [ 0.84147098  0.90929743  0.14112001 -0.7568025 ]


### 3.4.5 聚合函数

* 对一组值进行操作，返回一个单一值作为结果的函数


```python
a = np.arange(1,10)
print('Sum=',a.sum())
print('Min=',a.min())
print('Max=',a.max())
print('Mean=',a.mean())
print('Std=',a.std())
```

    Sum= 45
    Min= 1
    Max= 9
    Mean= 5.0
    Std= 2.58198889747


## 3.5 索引机制、切片和迭代方法

### 3.5.3 数组迭代



```python
A= np.arange(10,19).reshape(3,3)
for row in A:
    print(row)    
```

    [10 11 12]
    [13 14 15]
    [16 17 18]



```python
for item in A.flat:
    print(item)
```

    10
    11
    12
    13
    14
    15
    16
    17
    18


* 用聚合函数处理每一行/列，返回一个数值作为结果最好用纯NumPy方法处理循环：   
 >apply_along_axis()


```python
np.apply_along_axis(np.mean,axis=0,arr=A)
```




    array([ 13.,  14.,  15.])




```python
np.apply_along_axis(np.mean,axis=1,arr=A)
```




    array([ 11.,  14.,  17.])



## 3.6 条件和布尔数组


```python
A = np.random.random((4,4))
A
```




    array([[ 0.53814304,  0.24153109,  0.20325531,  0.07824418],
           [ 0.99506676,  0.80020976,  0.75630931,  0.49604315],
           [ 0.6323257 ,  0.37460922,  0.26048766,  0.93911101],
           [ 0.36938058,  0.44149862,  0.42227293,  0.39001975]])




```python
A<0.5
```




    array([[False,  True,  True,  True],
           [False, False, False,  True],
           [False,  True,  True, False],
           [ True,  True,  True,  True]], dtype=bool)




```python
A[ A<0.5 ]
```




    array([ 0.24153109,  0.20325531,  0.07824418,  0.49604315,  0.37460922,
            0.26048766,  0.36938058,  0.44149862,  0.42227293,  0.39001975])



## 3.7 形状变换


```python
a = np.random.random(12)
a
```




    array([ 0.09080643,  0.52156794,  0.91141779,  0.43507082,  0.14662574,
            0.73397909,  0.16817834,  0.7769363 ,  0.33684968,  0.07905848,
            0.30365698,  0.73899297])




```python
A = a.reshape(3,4)
A
```




    array([[ 0.09080643,  0.52156794,  0.91141779,  0.43507082],
           [ 0.14662574,  0.73397909,  0.16817834,  0.7769363 ],
           [ 0.33684968,  0.07905848,  0.30365698,  0.73899297]])




```python
a.shape=(3,4)
a
```




    array([[ 0.09080643,  0.52156794,  0.91141779,  0.43507082],
           [ 0.14662574,  0.73397909,  0.16817834,  0.7769363 ],
           [ 0.33684968,  0.07905848,  0.30365698,  0.73899297]])




```python
a = a.ravel()
a
```




    array([ 0.09080643,  0.52156794,  0.91141779,  0.43507082,  0.14662574,
            0.73397909,  0.16817834,  0.7769363 ,  0.33684968,  0.07905848,
            0.30365698,  0.73899297])




```python
a.shape = (12)
a
```




    array([ 0.09080643,  0.52156794,  0.91141779,  0.43507082,  0.14662574,
            0.73397909,  0.16817834,  0.7769363 ,  0.33684968,  0.07905848,
            0.30365698,  0.73899297])




```python
A.transpose()
```




    array([[ 0.09080643,  0.14662574,  0.33684968],
           [ 0.52156794,  0.73397909,  0.07905848],
           [ 0.91141779,  0.16817834,  0.30365698],
           [ 0.43507082,  0.7769363 ,  0.73899297]])



## 3.8 数组操作

### 3.8.1 连接数组 

* vstack() 垂直入栈操作，把第二个数组作为行加到第一个数组，数组朝垂直方向生长。   
* hstack() 水平入栈操作，把第二个数组作为列加到第一个数组，数组朝水平方向生长。


```python
A = np.ones((3,3))
B = np.zeros((3,3))
np.vstack((A,B))
```




    array([[ 1.,  1.,  1.],
           [ 1.,  1.,  1.],
           [ 1.,  1.,  1.],
           [ 0.,  0.,  0.],
           [ 0.,  0.,  0.],
           [ 0.,  0.,  0.]])




```python
np.hstack((A,B))
```




    array([[ 1.,  1.,  1.,  0.,  0.,  0.],
           [ 1.,  1.,  1.,  0.,  0.,  0.],
           [ 1.,  1.,  1.,  0.,  0.,  0.]])



* colum_stack(), row_stack() 这两个func把一维数组作为列或行压入栈结构，形成新的二维数组。


```python
a = np.array([0,1,2])
b = np.array([3,4,5])
c = np.array([6,7,7])
np.column_stack((a,b,c))
```




    array([[0, 3, 6],
           [1, 4, 7],
           [2, 5, 7]])




```python
np.row_stack((a,b,c))
```




    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 7]])



### 3.8.2 数组切分
* hsplit( ) 水平切割    
 vsplit( ) 垂直切割


```python
A = np.arange(16).reshape((4,4))
A
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
[B,C] = np.hsplit(A,2)
B
```




    array([[ 0,  1],
           [ 4,  5],
           [ 8,  9],
           [12, 13]])




```python
C
```




    array([[ 2,  3],
           [ 6,  7],
           [10, 11],
           [14, 15]])




```python
[D,E] = np.vsplit(A,2)
D
```




    array([[0, 1, 2, 3],
           [4, 5, 6, 7]])




```python
E
```




    array([[ 8,  9, 10, 11],
           [12, 13, 14, 15]])



* split( ) 可以把数组分为几个不对称的部分，必须指定传入数组，被切部分索引。
* axis=1 列索引 ; axis=0 行索引


```python
[A1,A2,A3] = np.split(A,[1,3],axis=1)
A1
```




    array([[ 0],
           [ 4],
           [ 8],
           [12]])




```python
A2
```




    array([[ 1,  2],
           [ 5,  6],
           [ 9, 10],
           [13, 14]])




```python
A3
```




    array([[ 3],
           [ 7],
           [11],
           [15]])




```python
[A1,A2,A3] = np.split(A,[1,3],axis=0)
A1
```




    array([[0, 1, 2, 3]])




```python
A2
```




    array([[ 4,  5,  6,  7],
           [ 8,  9, 10, 11]])




```python
A3
```




    array([[12, 13, 14, 15]])



## 3.9 常用概念
 
### 3.9.1 Object 的副本/视图
> c = a.copy( )   

### 3.9.2 向量化
* 数组相乘 a * b   
* 矩阵相乘 A * B   

### 3.9.3 广播机制
* 实现对>=2个数组的运算/函数处理，即使这些数组形状并不完全相同。   
* if 两个数组的各维度兼容，即两个数组对每一维等长 or 其中一组为一维，即适用广播机制。   


```python
A = np.arange(16).reshape(4,4)
b = np.arange(4)
A
```




    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])




```python
b
```




    array([0, 1, 2, 3])




```python
A + b
```




    array([[ 0,  2,  4,  6],
           [ 4,  6,  8, 10],
           [ 8, 10, 12, 14],
           [12, 14, 16, 18]])



* 拓展最小维度数组，使两数组维度相同可以叠加
> b --> b*   
>        array([[ 0, 1, 2, 3],   
>               [ 0, 1, 2, 3],   
>               [ 0, 1, 2, 3],   
>               [ 0, 1, 2, 3]])   


```python
m = np.arange(6).reshape(3,1,2)
n = np.arange(6).reshape(3,2,1)
m
```




    array([[[0, 1]],
    
           [[2, 3]],
    
           [[4, 5]]])




```python
n
```




    array([[[0],
            [1]],
    
           [[2],
            [3]],
    
           [[4],
            [5]]])



* 这种情况下，两个数组都要拓展维度（broadcasting）
 > m* = array([[ [0, 1], [0, 1]], [[2, 3], [2, 3]], [[4, 5], [4, 5] ]])           
 > n* = array([ [[0, 0], [1, 1]], [[2, 2], [3, 3]], [[4, 4], [5, 5] ]])


```python
m + n
```




    array([[[ 0,  1],
            [ 1,  2]],
    
           [[ 4,  5],
            [ 5,  6]],
    
           [[ 8,  9],
            [ 9, 10]]])



## 3.11 数组数据文件的读写

### 3.11.1 二进制文件的读写
* Numpy 的 save( ) 方法以二进制格式保存数据，load( )方法从二进制文件中读取数据。
- et cetra:   
> data   #为一组array   
> np.save('saved_data',data)   
* 保存的文件以 .npy 为拓展名   
> loaded_data = np.load('saved_data.npy')   
> loaded_data   #为一组array

### 3.11.2 读取文件的列表形式数据
* genformtxt( ) 可以从文本文件中读取数据并将其插入数组中。
> data = np.genformtxt('data.csv', delimiter=',', names=True)
